{-|
Module      : Cucumber
Description : Cucumber testing for daml
Copyright   : (c) Obsidian Systems LLC, 2024
License     : BSD-3-Clause
Maintainer  : maintainer@obsidian.systems

Support library for daml-cucumber. Use this library to implement
cucumber/gherkin steps in daml, and use the daml-cucumber tool to run them.
-}
module Cucumber
  ( module Cucumber
  , module LiftScript
  , module StateT
  ) where

import DA.Action
import DA.Action.State.Class
import DA.Exception
import DA.Set
import Daml.Script
import LiftScript
import StateT

data StepKey = StepKey
  { keyword : Keyword
  , identifier : Text
  }
  deriving (Eq, Show, Ord)

data Message
  = StepComplete StepKey
  | ScenarioComplete Text
  | DuplicateStepFound StepKey
  | DuplicateScenarioFound Text

data Keyword = Given | When | Then | And | But
  deriving (Eq, Show, Enum, Bounded, Ord)

data StepResult = StepResult
  with
    stepKeyword : Keyword
    ident : Text
    success : Bool

tryCatch
  : Script a
  -> Script (Either Text a)
tryCatch f = do
  try
    Right <$> f
  catch
    e@(GeneralError msg) -> do
      pure $ Left msg
    e@(PreconditionFailed msg) -> do
      pure $ Left msg
    e@(AssertionFailed msg) -> do
      pure $ Left msg
    e@(ArithmeticError msg) -> do
      pure $ Left msg

data Context = Context
  { currentScenario : Optional Text
  , currentStep : Optional StepKey
  , scenarioRecords : Set Text
  , stepRecords : Set StepKey
  , results : [Message]
  }

newtype Cucumber a = Cucumber
  { unCucumber : StateT Context Script a
  }
 deriving (Functor, Applicative, Action, ActionState Context)

instance LiftScript Cucumber where
  liftScript action = Cucumber (liftScript action)

startingContext: Context
startingContext = Context None None mempty mempty mempty

runCucumber: Cucumber a -> Script (a, Context)
runCucumber testAction =
  runState startingContext action
  where
    Cucumber action = do
      result <- testAction
      tryRecordStep
      tryRecordScenario
      pure result

gets : (Applicative m, ActionState s m) => (s -> a) -> m a
gets f = f <$> get

report : Message -> Cucumber ()
report msg =
  modify $ \c -> c{ results = c.results <> [msg] }

tryRecordScenario : Cucumber ()
tryRecordScenario = do
  -- Record the results of the current scenario
  records <- gets scenarioRecords
  scenario <- gets currentScenario
  case scenario of
    Some name -> do
      when (member name records) $ report $ DuplicateScenarioFound name
      report $ ScenarioComplete name
      modify (\c -> c { scenarioRecords = insert name c.scenarioRecords
                      , currentScenario = None
                      })
    _ -> pure ()

tryRecordStep : Cucumber ()
tryRecordStep = do
  -- Record the results of the current step
  records <- gets stepRecords
  step <- gets currentStep
  case step of
    Some key -> do
      when (member key records) $ report $ DuplicateStepFound key
      report $ StepComplete key
      modify (\c -> c { stepRecords = insert key c.stepRecords
                      , currentStep = None
                      })
    _ -> pure ()

-- TODO remove the conflict in this name with Prelude.scenario
scenario' : Text -> Cucumber ()
scenario' name = do
  tryRecordStep
  tryRecordScenario

  -- 'Push' on the current step
  modify (\c -> c { currentScenario = Some name })

step : Keyword -> Text -> Cucumber ()
step keyword ident = do
  tryRecordStep
  -- 'Push' on the current step
  modify (\c -> c { currentStep = Some (StepKey keyword ident) })
