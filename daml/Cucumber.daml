module Cucumber where

import DA.Action
import DA.Action.State.Class
import DA.Exception
import DA.Set
import Daml.Script
import StateT

data StepKey = StepKey
  { keyword: Keyword
  , identifier: Text
  }
  deriving (Eq, Show, Ord)

data Message
  = StepComplete StepKey
  | ScenarioComplete Text
  | DuplicateStepFound StepKey
  | DuplicateScenarioFound Text

data Keyword = Given | When | Then | And | But
  deriving (Eq, Show, Enum, Bounded, Ord)

data StepResult = StepResult
  with
    stepKeyword: Keyword
    ident: Text
    success: Bool

tryCatch
  : Script a
  -> Script (Either Text a)
tryCatch f = do
  try
    Right <$> f
  catch
    e@(GeneralError msg) -> do
      pure $ Left msg
    e@(PreconditionFailed msg) -> do
      pure $ Left msg
    e@(AssertionFailed msg) -> do
      pure $ Left msg
    e@(ArithmeticError msg) -> do
      pure $ Left msg

data Context = Context
  { currentScenario : Optional Text
  , currentStep: Optional StepKey
  , scenarioRecords: Set Text
  , stepRecords: Set StepKey
  , results: [Message]
  }

newtype Cucumber a = Cucumber
  { unCucumber: StateT Context Script a
  }
 deriving (Functor, Applicative, Action, ActionState Context)

instance LiftScript Cucumber where
  liftScript action = Cucumber (liftScript action)

startingContext: Context
startingContext = Context None None mempty mempty mempty

runCucumber: Cucumber a -> Script (a, Context)
runCucumber testAction =
  runState startingContext action
  where
    Cucumber action = do
      result <- testAction
      tryRecordStep
      tryRecordScenario
      pure result

gets: (Applicative m, ActionState s m) => (s -> a) -> m a
gets f = f <$> get

report: Message -> Cucumber ()
report msg =
  modify $ \c -> c{ results = c.results <> [msg] }

tryRecordScenario: Cucumber ()
tryRecordScenario = do
  -- Record the results of the current scenario
  records <- gets scenarioRecords
  scenario <- gets currentScenario
  case scenario of
    Some name -> do
      when (member name records) $ report $ DuplicateScenarioFound name
      report $ ScenarioComplete name
      modify (\c -> c { scenarioRecords = insert name c.scenarioRecords
                      , currentScenario = None
                      })
    _ -> pure ()

tryRecordStep: Cucumber ()
tryRecordStep = do
  -- Record the results of the current step
  records <- gets stepRecords
  step <- gets currentStep
  case step of
    Some key -> do
      when (member key records) $ report $ DuplicateStepFound key
      report $ StepComplete key
      modify (\c -> c { stepRecords = insert key c.stepRecords
                      , currentStep = None
                      })
    _ -> pure ()

-- TODO remove the conflict in this name with Prelude.scenario
scenario': Text -> Cucumber ()
scenario' name = do
  tryRecordStep
  tryRecordScenario

  -- 'Push' on the current step
  modify (\c -> c { currentScenario = Some name })

step: Keyword -> Text -> Cucumber ()
step keyword ident = do
  tryRecordStep

  -- 'Push' on the current step
  modify (\c -> c { currentStep = Some (StepKey keyword ident) })
